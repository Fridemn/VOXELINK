<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOXELINK å®æ—¶è¯­éŸ³è¯†åˆ«æ¼”ç¤º - é‡æ„ç‰ˆ</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        .status-bar {
            margin: 20px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .status-indicator {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
            background-color: #e74c3c;
        }
        .status-indicator.connected {
            background-color: #2ecc71;
        }
        .settings {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
        .settings-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .settings-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            background-color: #3498db;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        button.stop {
            background-color: #e74c3c;
        }
        button.stop:hover {
            background-color: #c0392b;
        }
        .voice-activity {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        .voice-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #bdc3c7;
            margin-right: 10px;
            transition: background-color 0.3s;
        }
        .voice-indicator.active {
            background-color: #2ecc71;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .recording-status {
            margin: 10px 0;
            padding: 8px;
            background-color: #e8f4fd;
            border-radius: 4px;
            font-weight: bold;
            color: #2c3e50;
        }
        .transcript-container {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            background-color: #fff;
        }
        .transcript {
            white-space: pre-wrap;
            line-height: 1.5;
        }        .message {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        .user-message {
            background-color: #e8f4fd;
            border-left: 3px solid #3498db;
        }
        .vad-debug-panel {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        .vad-debug-panel h3 {
            margin-top: 0;
            color: #2c3e50;
            font-size: 16px;
        }
        .vad-meter {
            margin: 10px 0;
            height: 20px;
            background-color: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        .vad-meter-fill {
            height: 100%;
            background-color: #3498db;
            transition: width 0.2s ease-out;
            position: absolute;
            left: 0;
            top: 0;
        }
        .vad-meter-threshold {
            height: 100%;
            width: 2px;
            background-color: #e74c3c;
            position: absolute;
            transition: left 0.2s ease-out;
        }
        .vad-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .vad-stat-item {
            background-color: white;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        .vad-stat-label {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 4px;
        }
        .vad-stat-value {
            font-size: 14px;
            font-weight: bold;
            color: #2c3e50;
        }
        .system-message {
            background-color: #f8f9fa;
            border-left: 3px solid #95a5a6;
            font-style: italic;
            color: #7f8c8d;
        }
        .partial-result {
            background-color: #fff3cd;
            border-left: 3px solid #ffc107;
            font-style: italic;
        }
        .error-message {
            background-color: #f8d7da;
            border-left: 3px solid #dc3545;
            color: #721c24;
        }
        .llm-response {
            background-color: #d1ecf1;
            border-left: 3px solid #0c5460;
            font-style: normal;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }
        .llm-response-header {
            font-weight: bold;
            color: #0c5460;
            margin-bottom: 5px;
        }
        .info-text {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            padding: 15px;
            border-radius: 4px;
            color: #0c5460;
        }
        .info-text p {
            margin: 8px 0;
        }
        input[type="text"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        input[type="checkbox"] {
            margin-right: 5px;
        }
        label {
            font-weight: normal;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤ VOXELINK å®æ—¶è¯­éŸ³è¯†åˆ«æ¼”ç¤º</h1>
          <div class="status-bar">            <div>
                <span class="status-indicator" id="connection-status"></span>
                <span id="status-text">æœªè¿æ¥</span>
            </div>
            <div>
                <span id="server-info">æœåŠ¡å™¨: æœªè¿æ¥</span> | 
                <span id="userInfo">ç”¨æˆ·: æœªè¯†åˆ«</span> | 
                <span id="audio-format">éŸ³é¢‘æ ¼å¼: WAV</span>
            </div>
        </div>
        
        <div class="settings">
            <h3>è®¾ç½®</h3>
            <div class="settings-row">
                <div class="settings-item">
                    <input type="checkbox" id="check-voiceprint" checked>
                    <label for="check-voiceprint">å¯ç”¨å£°çº¹æ£€æŸ¥</label>
                </div>
                <div class="settings-item">
                    <input type="checkbox" id="only-register-user">
                    <label for="only-register-user">ä»…è¯†åˆ«å·²æ³¨å†Œç”¨æˆ·</label>
                </div>
                <div class="settings-item">
                    <input type="checkbox" id="identify-unregistered" checked>
                    <label for="identify-unregistered">è¯†åˆ«æœªæ³¨å†Œç”¨æˆ·</label>
                </div>
            </div>
            <div class="settings-row">
                <div class="settings-item">
                    <label for="server-url">æœåŠ¡å™¨åœ°å€:</label>
                    <input type="text" id="server-url" value="ws://localhost:8080/stt/ws" style="width: 250px;">
                </div>
                <div class="settings-item">
                    <label for="api-key">APIå¯†é’¥:</label>
                    <input type="text" id="api-key" placeholder="å¯é€‰" style="width: 250px;">
                </div>
            </div>
            <div class="settings-row">
                <div class="settings-item">
                    <label for="user-token">ç”¨æˆ·Token:</label>
                    <input type="text" id="user-token" placeholder="ç”¨äºLLMè°ƒç”¨çš„ç”¨æˆ·Token" style="width: 400px;">
                </div>
            </div>
            <div class="settings-row">
                <div class="settings-item">
                    <label for="llm-api-url">LLM APIåœ°å€:</label>
                    <input type="text" id="llm-api-url" placeholder="ä¾‹å¦‚: http://localhost:8080/llm/chat" style="width: 400px;">
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button id="connect-btn">è¿æ¥æœåŠ¡å™¨</button>
            <button id="disconnect-btn" disabled>æ–­å¼€è¿æ¥</button>
            <button id="start-btn" disabled>å¼€å§‹å½•éŸ³</button>
            <button id="stop-btn" class="stop" disabled>åœæ­¢å½•éŸ³</button>
            <button id="clear-btn">æ¸…ç©ºè®°å½•</button>
        </div>
        
        <div class="voice-activity">
            <div class="voice-indicator" id="voice-indicator"></div>
            <span id="voice-status">æœªæ£€æµ‹åˆ°è¯­éŸ³</span>
        </div>
          <div class="recording-status">
            <span id="recording-status">æœªå¼€å§‹å½•éŸ³</span>
        </div>
        
        <!-- VADè°ƒè¯•é¢æ¿ -->
        <div class="vad-debug-panel">
            <h3>VAD å®æ—¶è°ƒè¯•ä¿¡æ¯</h3>
            <div class="vad-meter">
                <div class="vad-meter-fill" id="vad-meter-fill"></div>
                <div class="vad-meter-threshold" id="vad-meter-threshold"></div>
            </div>
            <div class="vad-stats">
                <div class="vad-stat-item">
                    <div class="vad-stat-label">å½“å‰RMS</div>
                    <div class="vad-stat-value" id="vad-rms">0.000</div>
                </div>
                <div class="vad-stat-item">
                    <div class="vad-stat-label">é˜ˆå€¼</div>
                    <div class="vad-stat-value" id="vad-threshold">0.025</div>
                </div>
                <div class="vad-stat-item">
                    <div class="vad-stat-label">VADç½®ä¿¡åº¦</div>
                    <div class="vad-stat-value" id="vad-confidence">0.00</div>
                </div>
                <div class="vad-stat-item">
                    <div class="vad-stat-label">è¯­éŸ³çŠ¶æ€</div>
                    <div class="vad-stat-value" id="vad-status">é™éŸ³</div>
                </div>
                <div class="vad-stat-item">
                    <div class="vad-stat-label">éŸ³é¢‘æ—¶é•¿</div>
                    <div class="vad-stat-value" id="audio-duration">0.00s</div>
                </div>
            </div>
        </div>
        
        <div class="transcript-container">
            <div class="transcript" id="transcript"></div>
        </div>
        
        <div class="info-text" style="margin-top: 15px;">
            <p><strong>ä½¿ç”¨è¯´æ˜:</strong></p>
            <p>1. <strong>é…ç½®LLMæœåŠ¡</strong>: åœ¨"LLM APIåœ°å€"è¾“å…¥æ¡†ä¸­è¾“å…¥æ‚¨çš„LLMæœåŠ¡APIåœ°å€</p>
            <p>2. <strong>è¾“å…¥ç”¨æˆ·Token</strong>: åœ¨"ç”¨æˆ·Token"è¾“å…¥æ¡†ä¸­è¾“å…¥æ‚¨çš„LLM API Token</p>
            <p>3. ç‚¹å‡»"è¿æ¥æœåŠ¡å™¨"è¿æ¥åˆ°è¯­éŸ³è¯†åˆ«æœåŠ¡</p>
            <p>4. ç‚¹å‡»"å¼€å§‹å½•éŸ³"å¼€å§‹å®æ—¶è¯­éŸ³è¯†åˆ«</p>
            <p>5. å¯¹ç€éº¦å…‹é£è¯´è¯ï¼Œç³»ç»Ÿä¼šå®æ—¶æ˜¾ç¤ºè¯†åˆ«ç»“æœ</p>
            <p>6. <strong>è‡ªåŠ¨LLMè°ƒç”¨</strong>: å¦‚æœé…ç½®äº†Tokenå’ŒAPIåœ°å€ï¼Œè¯†åˆ«åˆ°çš„æ–‡æœ¬ä¼šè‡ªåŠ¨å‘é€ç»™LLMå¹¶æ˜¾ç¤ºå“åº”</p>
            <p>7. ç»¿è‰²æŒ‡ç¤ºç¯äº®èµ·è¡¨ç¤ºæ­£åœ¨æ£€æµ‹åˆ°è¯­éŸ³</p>
            <p><strong>æ³¨æ„:</strong> 
               <br>â€¢ è¯·ç¡®ä¿æµè§ˆå™¨æ”¯æŒWebSocketå’Œéº¦å…‹é£è®¿é—®æƒé™
               <br>â€¢ LLMåŠŸèƒ½éœ€è¦é…ç½®æ­£ç¡®çš„APIåœ°å€å’ŒToken
               <br>â€¢ è¯†åˆ«ç»“æœä¼šè‡ªåŠ¨æ¸…ç†æ‰è¯­éŸ³è¯†åˆ«çš„æŠ€æœ¯æ ‡è®°ï¼Œåªå‘é€çº¯æ–‡æœ¬ç»™LLM
            </p>
        </div>
    </div>

    <script>        // é…ç½®å‚æ•°
        const CONFIG = {
            SAMPLE_RATE: 16000,
            CHANNELS: 1,
            CHUNK_SIZE: 2048,
            VAD_THRESHOLD: 0.15,          // é™ä½VADé˜ˆå€¼ï¼Œä½¿å…¶æ›´å®¹æ˜“æ£€æµ‹åˆ°è¯­éŸ³
            MIN_SPEECH_FRAMES: 2,          // è¾ƒå°çš„è¯­éŸ³å¸§æ•°ï¼Œæ›´å¿«å¼€å§‹è¯†åˆ«
            MAX_SILENCE_FRAMES: 5,         // å¤§å¹…å‡å°‘é™éŸ³å¸§æ•°ï¼Œæ›´å¿«ç»“æŸè¯†åˆ«
            AUDIO_RMS_THRESHOLD: 0.025,    // æ›´ä½çš„éŸ³é¢‘RMSé˜ˆå€¼ï¼Œæé«˜æ£€æµ‹çµæ•åº¦
            REAL_TIME_FRAMES: 15,          // å‡å°‘å®æ—¶è¯†åˆ«æ‰€éœ€çš„å¸§æ•°
            TAIL_THRESHOLD_RATIO: 0.4,     // è¯­éŸ³ç»“å°¾åˆ¤æ–­çš„é˜ˆå€¼æ¯”ä¾‹ï¼Œæ•°å€¼åº”å°äº1
            SPEECH_PADDING_FRAMES: 2,      // åœ¨è¯­éŸ³å¼€å§‹å‰æ·»åŠ çš„é¢å¤–å¸§æ•°
            END_SPEECH_DELAY_MS: 300,      // è¯­éŸ³ç»“æŸåçš„é¢å¤–å»¶è¿Ÿæ—¶é—´(æ¯«ç§’)
        };

        // DOMå…ƒç´         
        const elements = {
            connectBtn: document.getElementById('connect-btn'),
            disconnectBtn: document.getElementById('disconnect-btn'),
            startBtn: document.getElementById('start-btn'),
            stopBtn: document.getElementById('stop-btn'),
            clearBtn: document.getElementById('clear-btn'),
            transcript: document.getElementById('transcript'),
            connectionStatus: document.getElementById('connection-status'),
            statusText: document.getElementById('status-text'),
            serverInfo: document.getElementById('server-info'),
            userInfo: document.getElementById('userInfo'),
            serverUrl: document.getElementById('server-url'),
            apiKey: document.getElementById('api-key'),
            userToken: document.getElementById('user-token'),  // æ·»åŠ ç”¨æˆ·tokenå…ƒç´ 
            llmApiUrl: document.getElementById('llm-api-url'),  // æ·»åŠ LLM API URLå…ƒç´ 
            checkVoiceprint: document.getElementById('check-voiceprint'),
            onlyRegisterUser: document.getElementById('only-register-user'),            identifyUnregistered: document.getElementById('identify-unregistered'),
            voiceIndicator: document.getElementById('voice-indicator'),
            voiceStatus: document.getElementById('voice-status'),
            recordingStatus: document.getElementById('recording-status'),
            audioFormat: document.getElementById('audio-format'),
            // VADè°ƒè¯•é¢æ¿å…ƒç´ 
            vadMeterFill: document.getElementById('vad-meter-fill'),
            vadMeterThreshold: document.getElementById('vad-meter-threshold'),
            vadRms: document.getElementById('vad-rms'),
            vadThreshold: document.getElementById('vad-threshold'),
            vadConfidence: document.getElementById('vad-confidence'),
            vadStatus: document.getElementById('vad-status'),
            audioDuration: document.getElementById('audio-duration')
        };

        // çŠ¶æ€å˜é‡
        let socket = null;
        let audioContext = null;
        let mediaStream = null;
        let audioProcessor = null;
        let isRecording = false;
        let isConnected = false;
        let isSpeaking = false;
        let speechFrames = [];
        let silenceFrames = 0;        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus(connected) {
            isConnected = connected;
            elements.connectionStatus.classList.toggle('connected', connected);
            elements.statusText.textContent = connected ? 'å·²è¿æ¥' : 'æœªè¿æ¥';
            elements.connectBtn.disabled = connected;
            elements.disconnectBtn.disabled = !connected;
            elements.startBtn.disabled = !connected;
            elements.stopBtn.disabled = true;
            
            const serverUrl = elements.serverUrl.value;
            elements.serverInfo.textContent = `æœåŠ¡å™¨: ${serverUrl}`;
            elements.audioFormat.textContent = `éŸ³é¢‘æ ¼å¼: PCM`;
        }

        // æ·»åŠ æ¶ˆæ¯åˆ°ç•Œé¢
        function addMessage(text, isSystem = false, isError = false) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');
            
            if (isError) {
                messageDiv.classList.add('error-message');
            } else if (isSystem) {
                messageDiv.classList.add('system-message');
            } else {
                messageDiv.classList.add('user-message');
            }
            
            const timestamp = new Date().toLocaleTimeString();
            messageDiv.textContent = `[${timestamp}] ${text}`;
            
            elements.transcript.appendChild(messageDiv);
            elements.transcript.scrollTop = elements.transcript.scrollHeight;
        }

        // æ·»åŠ LLMå“åº”åˆ°ç•Œé¢
        function addLLMResponse(llmResponse) {
            const responseDiv = document.createElement('div');
            responseDiv.classList.add('message', 'llm-response');
            
            const timestamp = new Date().toLocaleTimeString();
            const headerDiv = document.createElement('div');
            headerDiv.classList.add('llm-response-header');
            headerDiv.textContent = `[${timestamp}] AIåŠ©æ‰‹:`;
            
            const contentDiv = document.createElement('div');
            
            // å¤„ç†ä¸åŒç±»å‹çš„å“åº”
            if (llmResponse.error) {
                contentDiv.innerHTML = `<strong>é”™è¯¯:</strong> ${llmResponse.error}<br>`;
                if (llmResponse.details) {
                    contentDiv.innerHTML += `<em>è¯¦æƒ…:</em> ${llmResponse.details}`;
                }
                responseDiv.style.backgroundColor = '#f8d7da';
                responseDiv.style.borderLeftColor = '#dc3545';
            } else if (llmResponse.text) {
                // æ˜¾ç¤ºAIå“åº”çš„æ–‡æœ¬å†…å®¹
                contentDiv.textContent = llmResponse.text;
                
                // å¦‚æœæœ‰tokenä¿¡æ¯ï¼Œæ·»åŠ åˆ°åº•éƒ¨
                if (llmResponse.token_info) {
                    const tokenInfoDiv = document.createElement('div');
                    tokenInfoDiv.style.fontSize = '12px';
                    tokenInfoDiv.style.color = '#666';
                    tokenInfoDiv.style.marginTop = '8px';
                    tokenInfoDiv.textContent = `è¾“å…¥tokens: ${llmResponse.token_info.input_tokens}, è¾“å‡ºtokens: ${llmResponse.token_info.output_tokens}`;
                    contentDiv.appendChild(tokenInfoDiv);
                }
            } else {
                // æ˜¾ç¤ºåŸå§‹å“åº”ï¼ˆä½œä¸ºå¤‡ç”¨ï¼‰
                contentDiv.textContent = JSON.stringify(llmResponse, null, 2);
            }
            
            responseDiv.appendChild(headerDiv);
            responseDiv.appendChild(contentDiv);
            
            elements.transcript.appendChild(responseDiv);
            elements.transcript.scrollTop = elements.transcript.scrollHeight;
        }

        // è¿æ¥åˆ°WebSocketæœåŠ¡å™¨
        function connectToServer() {
            const serverUrl = elements.serverUrl.value;
            if (!serverUrl) {
                addMessage("è¯·è¾“å…¥æœåŠ¡å™¨åœ°å€", false, true);
                return;
            }

            try {
                addMessage(`æ­£åœ¨è¿æ¥åˆ° ${serverUrl}...`, true);
                socket = new WebSocket(serverUrl);                socket.onopen = () => {
                    addMessage("WebSocketè¿æ¥å·²å»ºç«‹", true);
                    updateStatus(true);
                    // è¿æ¥æˆåŠŸåå‘é€åˆå§‹é…ç½®
                    setTimeout(updateServerConfig, 100);
                };

                socket.onmessage = (event) => {
                    try {
                        const response = JSON.parse(event.data);
                        handleServerMessage(response);
                    } catch (error) {
                        console.error("è§£ææœåŠ¡å™¨æ¶ˆæ¯å¤±è´¥:", error);
                        addMessage(`è§£ææœåŠ¡å™¨æ¶ˆæ¯å¤±è´¥: ${error.message}`, false, true);
                    }
                };

                socket.onclose = (event) => {
                    addMessage(`WebSocketè¿æ¥å·²å…³é—­ (ä»£ç : ${event.code})`, true);
                    updateStatus(false);
                    stopRecording();
                };

                socket.onerror = (error) => {
                    addMessage(`WebSocketé”™è¯¯: ${error.message || 'æœªçŸ¥é”™è¯¯'}`, false, true);
                    updateStatus(false);
                };

            } catch (error) {
                addMessage(`è¿æ¥é”™è¯¯: ${error.message}`, false, true);
                updateStatus(false);
            }
        }        // å¤„ç†æœåŠ¡å™¨æ¶ˆæ¯
        function handleServerMessage(response) {
            console.log("æ”¶åˆ°æœåŠ¡å™¨å“åº”:", response);
            
            if (response.success) {
                if (response.text) {
                    // è¯­éŸ³è¯†åˆ«ç»“æœ
                    let resultText = response.text;
                    let userInfo = "";
                    
                    // å¤„ç†ç”¨æˆ·ä¿¡æ¯
                    if (response.user_id) {
                        const userName = response.user_name || response.user_id;
                        userInfo = `[${userName}]`;
                        
                        if (response.similarity) {
                            userInfo += ` (ç›¸ä¼¼åº¦: ${(response.similarity * 100).toFixed(1)}%)`;
                        }
                        
                        // æ›´æ–°çŠ¶æ€æ çš„ç”¨æˆ·ä¿¡æ¯
                        const userInfoElement = document.querySelector('#userInfo');
                        if (userInfoElement) {
                            userInfoElement.textContent = `ç”¨æˆ·: ${userName}`;
                        }
                    } else {
                        userInfo = "[æœªè¯†åˆ«ç”¨æˆ·]";
                        const userInfoElement = document.querySelector('#userInfo');
                        if (userInfoElement) {
                            userInfoElement.textContent = "ç”¨æˆ·: æœªè¯†åˆ«";
                        }
                    }
                    
                    // å¤„ç†è¯­éŸ³æ£€æµ‹è°ƒè¯•ä¿¡æ¯
                    if (response.speech_detection) {
                        const detection = response.speech_detection;
                        updateVadDebugPanel({
                            rms: detection.rms.value,
                            threshold: detection.rms.threshold,
                            confidence: detection.vad.confidence,
                            hasSpeech: detection.has_speech,
                            audioDuration: detection.audio_stats.duration
                        });
                    }
                    
                    // æ˜¾ç¤ºè¯†åˆ«ç»“æœ
                    addMessage(`${userInfo} ${resultText}`);
                    
                    // å¦‚æœæœ‰LLMå“åº”ï¼Œä¹Ÿæ˜¾ç¤ºå‡ºæ¥
                    if (response.llm_response) {
                        addLLMResponse(response.llm_response);
                    }
                    
                } else if (response.message) {
                    // ç³»ç»Ÿæ¶ˆæ¯ï¼ˆå¦‚é…ç½®æ›´æ–°ç¡®è®¤ï¼‰
                    addMessage(response.message, true);
                }
            } else if (response.error) {
                // é”™è¯¯æ¶ˆæ¯
                addMessage(`é”™è¯¯: ${response.error}`, false, true);
            }
        }// æ–­å¼€WebSocketè¿æ¥
        function disconnectFromServer() {
            if (socket) {
                socket.close();
                socket = null;
            }
            stopRecording();
            updateStatus(false);
        }

        // å¼€å§‹å½•éŸ³
        async function startRecording() {
            if (!isConnected) {
                addMessage("è¯·å…ˆè¿æ¥åˆ°æœåŠ¡å™¨", false, true);
                return;
            }

            try {
                // è¯·æ±‚éº¦å…‹é£æƒé™
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: CONFIG.SAMPLE_RATE,
                        channelCount: CONFIG.CHANNELS,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: CONFIG.SAMPLE_RATE
                });

                // åˆ›å»ºåª’ä½“æµæº
                const source = audioContext.createMediaStreamSource(mediaStream);

                // åˆ›å»ºå½•éŸ³å¤„ç†å™¨
                audioProcessor = audioContext.createScriptProcessor(CONFIG.CHUNK_SIZE, CONFIG.CHANNELS, CONFIG.CHANNELS);

                // è¿æ¥èŠ‚ç‚¹
                source.connect(audioProcessor);
                audioProcessor.connect(audioContext.destination);

                // è®¾ç½®å½•éŸ³çŠ¶æ€
                isRecording = true;
                isSpeaking = false;
                speechFrames = [];
                silenceFrames = 0;
                elements.startBtn.disabled = true;
                elements.stopBtn.disabled = false;

                // é‡ç½®è¯­éŸ³æŒ‡ç¤ºå™¨
                updateVoiceActivityIndicator(false);
                updateRecordingStatus("å·²å¼€å§‹æŒç»­å½•éŸ³ï¼Œç­‰å¾…è¯­éŸ³è¾“å…¥...");

                addMessage("å¼€å§‹å½•éŸ³ï¼Œè¯·è¯´è¯...", true);

                // éŸ³é¢‘å¤„ç†å›è°ƒ
                audioProcessor.onaudioprocess = (e) => {
                    if (!isRecording) return;                    // è·å–éŸ³é¢‘æ•°æ®
                    const inputBuffer = e.inputBuffer;
                    const inputData = inputBuffer.getChannelData(0);

                    // æ£€æµ‹éŸ³é‡ - ä½¿ç”¨æ›´åŠ æ•æ„Ÿçš„æ£€æµ‹æ–¹æ³•
                    const rms = calculateRMS(inputData);
                    
                    // åŠ¨æ€é˜ˆå€¼æ£€æµ‹ï¼šä½¿ç”¨å½“å‰RMSå€¼å’Œé˜ˆå€¼çš„æ¯”è¾ƒï¼Œæé«˜çµæ•åº¦
                    const isSpeech = rms > CONFIG.AUDIO_RMS_THRESHOLD;
                    
                    // æ›´æ–°VADè°ƒè¯•é¢æ¿
                    updateVadDebugPanel({
                        rms: rms,
                        threshold: CONFIG.AUDIO_RMS_THRESHOLD,
                        isSpeech: isSpeech,
                        audioDuration: inputBuffer.length / CONFIG.SAMPLE_RATE
                    });
                    
                    // è®°å½•RMSå€¼ä»¥è¿›è¡Œè°ƒè¯•
                    if (isSpeaking || rms > CONFIG.AUDIO_RMS_THRESHOLD * 0.7) {
                        console.log(`RMS: ${rms.toFixed(6)}, é˜ˆå€¼: ${CONFIG.AUDIO_RMS_THRESHOLD}, æ˜¯è¯­éŸ³: ${isSpeech}`);
                    }

                    // å°†éŸ³é¢‘æ•°æ®è½¬æ¢ä¸ºInt16
                    const audioData = convertFloat32ToInt16(inputData);                    // VADçŠ¶æ€æœºé€»è¾‘
                    if (isSpeech) {
                        // æ£€æµ‹åˆ°è¯­éŸ³ï¼Œä¿å­˜éŸ³é¢‘å¸§
                        speechFrames.push(audioData);
                        
                        // æ£€æµ‹è¯­éŸ³å¼€å§‹
                        if (!isSpeaking) {
                            silenceFrames = 0; // é‡ç½®é™éŸ³å¸§è®¡æ•°
                            
                            // åªéœ€è¦å¾ˆå°‘çš„å¸§å°±å¼€å§‹è¯†åˆ«
                            if (speechFrames.length >= CONFIG.MIN_SPEECH_FRAMES) {
                                // åœ¨è¯­éŸ³å¼€å§‹æ—¶ï¼Œå°è¯•æ·»åŠ ä¹‹å‰çš„å‡ å¸§æ¥æ•è·å®Œæ•´çš„è¯­éŸ³å¼€å¤´
                                isSpeaking = true;
                                console.log(`è¯­éŸ³å¼€å§‹æ£€æµ‹åˆ°ï¼Œå½“å‰RMS: ${rms.toFixed(6)}`);
                                updateVoiceActivityIndicator(true);
                                updateRecordingStatus("æ­£åœ¨å½•åˆ¶è¯­éŸ³...");
                                
                                // è¯­éŸ³å¼€å§‹æ—¶ç«‹å³å‘é€ä¸€æ¬¡ï¼ŒåŠ å¿«é¦–æ¬¡è¯†åˆ«é€Ÿåº¦
                                const initialAudio = concatenateAudioChunks(speechFrames);
                                sendAudioToServer(initialAudio);
                                console.log("è¯­éŸ³å¼€å§‹ï¼Œå‘é€åˆå§‹è¯­éŸ³ç‰‡æ®µ");
                            }
                        } else {
                            // å·²ç»åœ¨è¯­éŸ³çŠ¶æ€ï¼Œç»§ç»­é‡ç½®é™éŸ³è®¡æ•°
                            silenceFrames = 0;
                        }                        // å®æ—¶è¯†åˆ«ï¼šæ¯ç§¯ç´¯ä¸€å®šå¸§æ•°å°±å‘é€
                        if (isSpeaking && speechFrames.length >= CONFIG.REAL_TIME_FRAMES) {
                            const audioToSend = concatenateAudioChunks(speechFrames);
                            sendAudioToServer(audioToSend);
                            console.log(`æŒç»­è¯­éŸ³ä¸­ï¼Œå‘é€è¯­éŸ³ç‰‡æ®µè¿›è¡Œè¯†åˆ«ï¼Œå¸§æ•°: ${speechFrames.length}`);
                            
                            // ä¿ç•™å°‘é‡é‡å å¸§ï¼Œä¿è¯è¿ç»­æ€§ï¼Œä½†é™ä½å»¶è¿Ÿ
                            speechFrames = speechFrames.slice(-2);
                        }
                    } else {
                        // é™éŸ³å¸§é€»è¾‘å¤„ç†
                        
                        // å¦‚æœå½“å‰æ­£åœ¨è¯´è¯çŠ¶æ€ï¼Œåˆ™å¤„ç†å¯èƒ½çš„è¯­éŸ³ç»“æŸ
                        if (isSpeaking) {
                            // å¢åŠ é™éŸ³å¸§è®¡æ•°
                            silenceFrames++;
                            
                            // æ”¶é›†å°‘é‡é™éŸ³å¸§ï¼Œä»¥ä¿ç•™è‡ªç„¶çš„è¯­éŸ³å°¾éƒ¨
                            if (silenceFrames <= CONFIG.SPEECH_PADDING_FRAMES) {
                                speechFrames.push(audioData);
                            }
                              // å½“é™éŸ³å¸§è¾¾åˆ°é˜ˆå€¼æ—¶ï¼Œåˆ¤æ–­è¯­éŸ³ç»“æŸ
                            if (silenceFrames >= CONFIG.MAX_SILENCE_FRAMES) {
                                // è¯­éŸ³ç»“æŸï¼Œå‘é€æœ€åçš„éŸ³é¢‘ç‰‡æ®µ
                                if (speechFrames.length > 0) {
                                    const finalAudio = concatenateAudioChunks(speechFrames);
                                    const finalRms = calculateRMSFromInt16Array(finalAudio);
                                    
                                    // ä½¿ç”¨æ›´ä½çš„é˜ˆå€¼åˆ¤æ–­æ˜¯å¦æœ‰æ•ˆè¯­éŸ³ï¼Œå‡ ä¹æ€»æ˜¯å‘é€
                                    if (finalRms > CONFIG.AUDIO_RMS_THRESHOLD * CONFIG.TAIL_THRESHOLD_RATIO) {
                                        sendAudioToServer(finalAudio);
                                        console.log(`æ£€æµ‹åˆ°è¯­éŸ³ç»“æŸï¼Œå‘é€æœ€ç»ˆè¯­éŸ³ç‰‡æ®µï¼ŒRMS: ${finalRms.toFixed(6)}, é˜ˆå€¼: ${(CONFIG.AUDIO_RMS_THRESHOLD * CONFIG.TAIL_THRESHOLD_RATIO).toFixed(6)}`);
                                    } else {
                                        console.log(`è¯­éŸ³ç»“æŸä½†RMSè¿‡ä½ï¼Œä¸å‘é€: ${finalRms.toFixed(6)} < ${(CONFIG.AUDIO_RMS_THRESHOLD * CONFIG.TAIL_THRESHOLD_RATIO).toFixed(6)}`);
                                    }
                                }

                                // é‡ç½®çŠ¶æ€
                                speechFrames = [];
                                isSpeaking = false;
                                updateVoiceActivityIndicator(false);
                                updateRecordingStatus("ç­‰å¾…è¯­éŸ³è¾“å…¥...");
                            }
                        }
                    }
                };

            } catch (error) {
                addMessage(`å½•éŸ³å¤±è´¥: ${error.message}`, false, true);
                console.error("å½•éŸ³é”™è¯¯:", error);
            }
        }

        // åœæ­¢å½•éŸ³
        function stopRecording() {
            isRecording = false;

            if (audioProcessor) {
                audioProcessor.disconnect();
                audioProcessor = null;
            }

            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }

            // é‡ç½®UIçŠ¶æ€
            elements.startBtn.disabled = false;
            elements.stopBtn.disabled = true;
            updateVoiceActivityIndicator(false);
            updateRecordingStatus("å½•éŸ³å·²åœæ­¢");

            if (isConnected) {
                addMessage("å½•éŸ³å·²åœæ­¢", true);
            }
        }        // å‘é€éŸ³é¢‘æ•°æ®åˆ°æœåŠ¡å™¨
        async function sendAudioToServer(audioBuffer) {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                addMessage("æœªè¿æ¥åˆ°æœåŠ¡å™¨ï¼Œæ— æ³•å‘é€éŸ³é¢‘", false, true);
                return;
            }

            try {
                // ä¸ºäº†é™ä½å»¶è¿Ÿï¼Œç›´æ¥å‘é€PCMæ•°æ®ï¼Œè€Œä¸è½¬æ¢ä¸ºWAVæ ¼å¼
                // è½¬æ¢ä¸ºBase64
                const base64Audio = arrayBufferToBase64(audioBuffer.buffer);

                // æ„å»ºæ¶ˆæ¯ - é€‚åº”é‡æ„åçš„WebSocket APIæ ¼å¼
                const message = {
                    action: "audio",
                    data: {
                        audio_data: base64Audio,
                        format: "pcm" // æ˜ç¡®æŒ‡å®šéŸ³é¢‘æ ¼å¼ä¸ºPCMï¼Œå‡å°‘è½¬æ¢å»¶è¿Ÿ
                    }
                };

                // å‘é€æ¶ˆæ¯
                socket.send(JSON.stringify(message));
                console.log(`å·²å‘é€PCMéŸ³é¢‘æ•°æ®ï¼Œå¤§å°: ${audioBuffer.byteLength} å­—èŠ‚`);

            } catch (error) {
                addMessage(`å‘é€éŸ³é¢‘é”™è¯¯: ${error.message}`, false, true);
                console.error("å‘é€éŸ³é¢‘é”™è¯¯:", error);
            }
        }

        // æ›´æ–°æœåŠ¡å™¨é…ç½®
        function updateServerConfig() {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                return; // å¦‚æœæœªè¿æ¥åˆ™ä¸å‘é€é…ç½®
            }

            const userToken = elements.userToken.value.trim();
            console.log("å‰ç«¯ï¼šå‡†å¤‡å‘é€é…ç½®æ›´æ–°ï¼Œç”¨æˆ·token:", userToken ? `${userToken.substring(0, 20)}...` : "æ— ");

            const configMessage = {
                action: "config",
                data: {
                    check_voiceprint: elements.checkVoiceprint.checked,
                    only_register_user: elements.onlyRegisterUser.checked,
                    identify_unregistered: elements.identifyUnregistered.checked,
                    user_token: userToken,  // æ·»åŠ ç”¨æˆ·token
                    llm_api_url: elements.llmApiUrl.value.trim()  // æ·»åŠ LLM API URL
                }
            };

            try {
                socket.send(JSON.stringify(configMessage));
                console.log("å‰ç«¯ï¼šå·²å‘é€é…ç½®æ›´æ–°:", configMessage.data);
            } catch (error) {
                addMessage(`é…ç½®æ›´æ–°å¤±è´¥: ${error.message}`, false, true);
            }
        }

        // è¾…åŠ©å‡½æ•°
        function calculateRMS(buffer) {
            let sum = 0;
            for (let i = 0; i < buffer.length; i++) {
                sum += buffer[i] * buffer[i];
            }
            return Math.sqrt(sum / buffer.length);
        }

        function calculateRMSFromInt16Array(int16Array) {
            let sum = 0;
            for (let i = 0; i < int16Array.length; i++) {
                const normalized = int16Array[i] / 32768.0;
                sum += normalized * normalized;
            }
            return Math.sqrt(sum / int16Array.length);
        }

        function convertFloat32ToInt16(buffer) {
            const int16Array = new Int16Array(buffer.length);
            for (let i = 0; i < buffer.length; i++) {
                int16Array[i] = Math.max(-32768, Math.min(32767, buffer[i] * 32768));
            }
            return int16Array;
        }

        function concatenateAudioChunks(chunks) {
            const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
            const result = new Int16Array(totalLength);
            let offset = 0;
            for (const chunk of chunks) {
                result.set(chunk, offset);
                offset += chunk.length;
            }
            return result;
        }

        function arrayBufferToBase64(buffer) {
            const binary = String.fromCharCode.apply(null, new Uint8Array(buffer));
            return btoa(binary);
        }        // å°†PCMæ•°æ®è½¬æ¢ä¸ºWAVæ ¼å¼
        function convertToWav(pcmData) {
            // WAVæ–‡ä»¶å¤´å‚æ•°
            const numChannels = CONFIG.CHANNELS;
            const sampleRate = CONFIG.SAMPLE_RATE;
            const bitsPerSample = 16; // Int16 = 16ä½
            const bytesPerSample = bitsPerSample / 8;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmData.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // å†™å…¥WAVæ–‡ä»¶å¤´ - æ³¨æ„è¿™é‡Œä½¿ç”¨æ ‡å‡†WAVæ ¼å¼
            // "RIFF"æ ‡è¯† - å¿…é¡»æ˜¯å¤§å†™
            writeString(view, 0, 'RIFF');
            // æ–‡ä»¶å¤§å° (æ–‡ä»¶æ€»å­—èŠ‚æ•° - 8) - ä½¿ç”¨å°ç«¯å­—èŠ‚åº (ç¬¬5ä¸ªå‚æ•°ä¸ºtrue)
            view.setUint32(4, 36 + dataSize, true);
            // "WAVE"æ ¼å¼ - å¿…é¡»æ˜¯å¤§å†™
            writeString(view, 8, 'WAVE');
            // "fmt "å­å—æ ‡è¯† (æ³¨æ„fmtåæœ‰ä¸€ä¸ªç©ºæ ¼)
            writeString(view, 12, 'fmt ');
            // å­å—å¤§å° (å›ºå®šä¸º16è¡¨ç¤ºPCMæ ¼å¼)
            view.setUint32(16, 16, true);
            // éŸ³é¢‘æ ¼å¼ (1 è¡¨ç¤º PCM)
            view.setUint16(20, 1, true);
            // é€šé“æ•°
            view.setUint16(22, numChannels, true);
            // é‡‡æ ·ç‡
            view.setUint32(24, sampleRate, true);
            // å­—èŠ‚ç‡ (= é‡‡æ ·ç‡ * é€šé“æ•° * æ¯ä¸ªæ ·æœ¬çš„å­—èŠ‚æ•°)
            view.setUint32(28, byteRate, true);
            // å—å¯¹é½ (= é€šé“æ•° * æ¯ä¸ªæ ·æœ¬çš„å­—èŠ‚æ•°)
            view.setUint16(32, blockAlign, true);
            // é‡‡æ ·ä½æ•°
            view.setUint16(34, bitsPerSample, true);
            // "data"å­å—æ ‡è¯†
            writeString(view, 36, 'data');
            // æ•°æ®å¤§å° (= é‡‡æ ·æ•° * é€šé“æ•° * æ¯ä¸ªæ ·æœ¬çš„å­—èŠ‚æ•°)
            view.setUint32(40, dataSize, true);

            // å†™å…¥PCMæ•°æ® - æ³¨æ„è¿™é‡Œä½¿ç”¨å°ç«¯å­—èŠ‚åº (ç¬¬3ä¸ªå‚æ•°ä¸ºtrue)
            const pcmOffset = 44;
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(pcmOffset + (i * bytesPerSample), pcmData[i], true);
            }

            return buffer;
        }

        // è¾…åŠ©å‡½æ•°ï¼šå°†å­—ç¬¦ä¸²å†™å…¥DataView
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }        function updateVoiceActivityIndicator(isActive) {
            if (isActive) {
                elements.voiceIndicator.classList.add('active');
                elements.voiceStatus.textContent = 'æ£€æµ‹åˆ°è¯­éŸ³ (æ­£åœ¨è¯†åˆ«)';
            } else {
                elements.voiceIndicator.classList.remove('active');
                elements.voiceStatus.textContent = 'ç­‰å¾…è¯­éŸ³è¾“å…¥';
            }
        }

        function updateRecordingStatus(status) {
            if (elements.recordingStatus) {
                elements.recordingStatus.textContent = status;
            }
        }

        function clearTranscript() {
            elements.transcript.innerHTML = '';
            addMessage("è®°å½•å·²æ¸…ç©º", true);
        }        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
        function initEventListeners() {
            elements.connectBtn.addEventListener('click', connectToServer);
            elements.disconnectBtn.addEventListener('click', disconnectFromServer);
            elements.startBtn.addEventListener('click', startRecording);
            elements.stopBtn.addEventListener('click', stopRecording);
            elements.clearBtn.addEventListener('click', clearTranscript);

            // é…ç½®å˜æ›´ç›‘å¬å™¨
            elements.checkVoiceprint.addEventListener('change', updateServerConfig);
            elements.onlyRegisterUser.addEventListener('change', updateServerConfig);
            elements.identifyUnregistered.addEventListener('change', updateServerConfig);
            elements.userToken.addEventListener('input', updateServerConfig);  // ä½¿ç”¨inputäº‹ä»¶ï¼Œå®æ—¶æ›´æ–°token
            elements.llmApiUrl.addEventListener('input', updateServerConfig);  // ä½¿ç”¨inputäº‹ä»¶ï¼Œå®æ—¶æ›´æ–°LLM API URL

            // é¡µé¢å…³é—­å‰æ¸…ç†èµ„æº
            window.addEventListener('beforeunload', () => {
                stopRecording();
                disconnectFromServer();
            });
        }

        // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
        function checkBrowserCompatibility() {
            if (!window.WebSocket) {
                addMessage("é”™è¯¯: æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWebSocketï¼Œè¯·ä½¿ç”¨ç°ä»£æµè§ˆå™¨", false, true);
                elements.connectBtn.disabled = true;
            }

            if (!window.AudioContext && !window.webkitAudioContext) {
                addMessage("é”™è¯¯: æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒAudioContextï¼Œæ— æ³•å½•åˆ¶éŸ³é¢‘", false, true);
                elements.startBtn.disabled = true;
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                addMessage("é”™è¯¯: æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ•è·ï¼Œè¯·ä½¿ç”¨ç°ä»£æµè§ˆå™¨å¹¶ç¡®ä¿ä½¿ç”¨HTTPSæˆ–localhost", false, true);
                elements.startBtn.disabled = true;
            }
        }        // æ›´æ–°VADè°ƒè¯•é¢æ¿
        function updateVadDebugPanel(data) {
            try {
                // ç¡®ä¿å…ƒç´ å­˜åœ¨
                if (!elements.vadMeterFill || !elements.vadMeterThreshold || 
                    !elements.vadRms || !elements.vadThreshold || 
                    !elements.vadConfidence || !elements.vadStatus || 
                    !elements.audioDuration) {
                    console.warn("VADè°ƒè¯•é¢æ¿å…ƒç´ ä¸å­˜åœ¨");
                    return;
                }
                
                // æ›´æ–°RMSèƒ½é‡æ˜¾ç¤º
                if (data.rms !== undefined) {
                    const rmsValue = data.rms;
                    const maxRmsValue = Math.max(0.1, data.threshold * 4); // åŠ¨æ€è°ƒæ•´æœ€å¤§å€¼
                    const rmsPercent = Math.min(100, (rmsValue / maxRmsValue) * 100);
                    
                    // æ›´æ–°èƒ½é‡æ¡
                    elements.vadMeterFill.style.width = `${rmsPercent}%`;
                    
                    // åˆ¤æ–­æ˜¯å¦æœ‰è¯­éŸ³ (ä¼˜å…ˆä½¿ç”¨hasSpeechï¼Œå¦åˆ™ä½¿ç”¨isSpeech)
                    const isSpeechDetected = data.hasSpeech !== undefined ? data.hasSpeech : data.isSpeech;
                    elements.vadMeterFill.style.backgroundColor = isSpeechDetected ? '#2ecc71' : '#3498db';
                    
                    // æ›´æ–°é˜ˆå€¼çº¿ä½ç½®
                    const thresholdPercent = Math.min(100, (data.threshold / maxRmsValue) * 100);
                    elements.vadMeterThreshold.style.left = `${thresholdPercent}%`;
                    
                    // æ›´æ–°æ•°å€¼æ˜¾ç¤º
                    elements.vadRms.textContent = rmsValue.toFixed(4);
                    elements.vadThreshold.textContent = data.threshold.toFixed(4);
                }
                
                // æ›´æ–°VADç½®ä¿¡åº¦
                if (data.confidence !== undefined) {
                    elements.vadConfidence.textContent = (data.confidence * 100).toFixed(1) + '%';
                }
                
                // æ›´æ–°è¯­éŸ³çŠ¶æ€
                const isSpeechDetected = data.hasSpeech !== undefined ? data.hasSpeech : data.isSpeech;
                if (isSpeechDetected !== undefined) {
                    elements.vadStatus.textContent = isSpeechDetected ? 'æ£€æµ‹åˆ°è¯­éŸ³' : 'é™éŸ³';
                    elements.vadStatus.style.color = isSpeechDetected ? '#2ecc71' : '#7f8c8d';
                }
                
                // æ›´æ–°éŸ³é¢‘æ—¶é•¿
                if (data.audioDuration !== undefined) {
                    elements.audioDuration.textContent = data.audioDuration.toFixed(2) + 's';
                }
            } catch (error) {
                console.error("æ›´æ–°VADè°ƒè¯•é¢æ¿å‡ºé”™:", error);
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        function init() {
            updateStatus(false);
            initEventListeners();
            addMessage("æ¬¢è¿ä½¿ç”¨VOXELINKå®æ—¶è¯­éŸ³è¯†åˆ«ç³»ç»Ÿ", true);
            addMessage("è¯·ç‚¹å‡»\"è¿æ¥æœåŠ¡å™¨\"æŒ‰é’®å¼€å§‹", true);
            checkBrowserCompatibility();
        }

        // å¯åŠ¨åº”ç”¨
        document.addEventListener('DOMContentLoaded', function() {
            init();
        });
    </script>
</body>
</html>
