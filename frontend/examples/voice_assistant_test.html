<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOXELINK - è¯­éŸ³åŠ©æ‰‹é›†æˆæµ‹è¯•</title>
    <style>
        @import "main.css";

    </style>
</head>
<body>
    <div class="container">
        <h1>VOXELINK - è¯­éŸ³åŠ©æ‰‹é›†æˆæµ‹è¯•</h1>

        <!-- =============================================================================== -->
        <!-- ========================== STT SECTION ======================================== -->
        <!-- =============================================================================== -->
        <section id="stt-section">
            <h2>ğŸ¤ å®æ—¶è¯­éŸ³è¯†åˆ« (STT)</h2>
            <div class="config-section">
                <h3>è¿æ¥ä¸è¯†åˆ«é…ç½®</h3>
                <div class="settings-row">
                    <div class="settings-item">
                        <label for="stt-server-url">æœåŠ¡å™¨åœ°å€:</label>
                        <input type="text" id="stt-server-url" value="ws://localhost:8765/ws">
                    </div>
                    <div class="settings-item">
                        <label for="stt-user-token">ç”¨æˆ·Token (ç”¨äºLLM):</label>
                        <input type="text" id="stt-user-token" placeholder="ç”¨äºLLMè°ƒç”¨çš„ç”¨æˆ·Token">
                    </div>
                </div>
                 <div class="settings-row">
                    <div class="settings-item">
                        <label for="stt-llm-api-url">LLM APIåœ°å€:</label>
                        <input type="text" id="stt-llm-api-url" placeholder="ä¾‹å¦‚: https://api.example.com/llm/chat">
                    </div>
                    <div class="settings-item">
                        <label for="stt-api-key">APIå¯†é’¥ (å¯é€‰):</label>
                        <input type="text" id="stt-api-key" placeholder="å¯é€‰">
                    </div>
                </div>
                <div class="settings-row">
                    <div class="settings-item-checkbox">
                        <input type="checkbox" id="stt-check-voiceprint" checked>
                        <label for="stt-check-voiceprint">å¯ç”¨å£°çº¹æ£€æŸ¥</label>
                    </div>
                    <div class="settings-item-checkbox">
                        <input type="checkbox" id="stt-only-register-user">
                        <label for="stt-only-register-user">ä»…è¯†åˆ«å·²æ³¨å†Œç”¨æˆ·</label>
                    </div>
                    <div class="settings-item-checkbox">
                        <input type="checkbox" id="stt-identify-unregistered" checked>
                        <label for="stt-identify-unregistered">è¯†åˆ«æœªæ³¨å†Œç”¨æˆ·</label>
                    </div>
                </div>
                <div>
                    <button id="stt-connect-btn">ğŸ”Œ è¿æ¥STTæœåŠ¡</button>
                    <button id="stt-disconnect-btn" disabled>ğŸ”Œ æ–­å¼€è¿æ¥</button>
                    <button id="stt-start-btn" disabled>â–¶ï¸ å¼€å§‹å½•éŸ³</button>
                    <button id="stt-stop-btn" class="stop" disabled>â¹ï¸ åœæ­¢å½•éŸ³</button>
                    <button id="stt-clear-btn">ğŸ—‘ï¸ æ¸…ç©ºè®°å½•</button>
                </div>
            </div>
            
            <div id="stt-connection-status" class="status disconnected">âŒ æœªè¿æ¥</div>
            
            <div class="vad-debug-panel">
                <h3>VAD å®æ—¶è°ƒè¯•ä¿¡æ¯</h3>
                 <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 10px;">
                    <div id="stt-voice-indicator" style="width: 20px; height: 20px; border-radius: 50%; background-color: #bdc3c7; transition: background-color 0.3s;"></div>
                    <span id="stt-voice-status">æœªæ£€æµ‹åˆ°è¯­éŸ³</span> | 
                    <span id="stt-recording-status" style="font-weight: bold;">æœªå¼€å§‹å½•éŸ³</span>
                </div>
                <div class="vad-meter">
                    <div class="vad-meter-fill" id="stt-vad-meter-fill" style="width: 0%;"></div>
                    <div class="vad-meter-threshold" id="stt-vad-meter-threshold" style="left: 50%;"></div>
                </div>
                <div class="vad-stats">
                    <div class="vad-stat-item"><div class="vad-stat-label">å½“å‰RMS</div><div class="vad-stat-value" id="stt-vad-rms">0.000</div></div>
                    <div class="vad-stat-item"><div class="vad-stat-label">é˜ˆå€¼</div><div class="vad-stat-value" id="stt-vad-threshold">0.05</div></div>
                    <div class="vad-stat-item"><div class="vad-stat-label">VADç½®ä¿¡åº¦</div><div class="vad-stat-value" id="stt-vad-confidence">0.00</div></div>
                    <div class="vad-stat-item"><div class="vad-stat-label">è¯­éŸ³çŠ¶æ€</div><div class="vad-stat-value" id="stt-vad-status">é™éŸ³</div></div>
                    <div class="vad-stat-item"><div class="vad-stat-label">éŸ³é¢‘æ—¶é•¿</div><div class="vad-stat-value" id="stt-audio-duration">0.00s</div></div>
                </div>
            </div>

            <div class="transcript-container">
                <div id="stt-transcript"></div>
            </div>
        </section>

        <!-- =============================================================================== -->
        <!-- ========================== TTS SECTION ======================================== -->
        <!-- =============================================================================== -->
        <section id="tts-section">
            <h2>ğŸµ è¯­éŸ³åˆæˆæ’­æ”¾ (TTS)</h2>
            <div class="config-section">
                <h3>è¿æ¥é…ç½®</h3>
                <div class="settings-row">
                    <div class="settings-item">
                        <label for="tts-serverUrl">æœåŠ¡å™¨åœ°å€:</label>
                        <input type="text" id="tts-serverUrl" value="ws://localhost:9880">
                    </div>
                    <div class="settings-item">
                        <label for="tts-token">Token (ç”¨äºæ ‡è¯†å®¢æˆ·ç«¯):</label>
                        <input type="text" id="tts-token" value="test-client-001" placeholder="è¾“å…¥æ‚¨çš„token">
                    </div>
                </div>
                <button id="tts-connectBtn">ğŸ”Œ è¿æ¥TTSæœåŠ¡</button>
                <button id="tts-disconnectBtn" disabled>ğŸ”Œ æ–­å¼€è¿æ¥</button>
            </div>

            <div id="tts-connectionStatus" class="status disconnected">âŒ æœªè¿æ¥</div>

            <div class="stats-grid">
                <div class="stat-card"><div class="stat-value" id="tts-totalReceived">0</div><div class="stat-label">æ€»æ¥æ”¶éŸ³é¢‘</div></div>
                <div class="stat-card"><div class="stat-value" id="tts-totalPlayed">0</div><div class="stat-label">å·²æ’­æ”¾</div></div>
                <div class="stat-card"><div class="stat-value" id="tts-queueLength">0</div><div class="stat-label">å¾…æ’­æ”¾é˜Ÿåˆ—</div></div>
                <div class="stat-card"><div class="stat-value" id="tts-connectionTime">--</div><div class="stat-label">è¿æ¥æ—¶é•¿</div></div>
            </div>

            <div class="audio-queue">
                <h3>ğŸ¼ éŸ³é¢‘æ’­æ”¾é˜Ÿåˆ—</h3>
                <div style="margin: 10px 0;">
                    <button disabled id="tts-playNextBtn">â–¶ï¸ æ’­æ”¾ä¸‹ä¸€ä¸ª</button>
                    <button disabled id="tts-pauseBtn">â¸ï¸ æš‚åœ</button>
                    <button disabled id="tts-stopBtn">â¹ï¸ åœæ­¢</button>
                    <button id="tts-clearQueueBtn">ğŸ—‘ï¸ æ¸…ç©ºé˜Ÿåˆ—</button>
                    <button id="tts-markAllUnplayedBtn">ğŸ”„ é‡ç½®çŠ¶æ€</button>
                    <label style="margin-left: 20px;">
                        <input type="checkbox" id="tts-autoPlay" checked> è‡ªåŠ¨æ’­æ”¾
                    </label>
                </div>
                <div id="tts-audioQueue">
                    <div style="text-align: center; color: #718096; padding: 20px;">æš‚æ— éŸ³é¢‘æ–‡ä»¶ï¼Œç­‰å¾…æ¥æ”¶...</div>
                </div>
            </div>

            <div class="log-section">
                <h3>ğŸ“‹ TTS è¿æ¥æ—¥å¿—</h3>
                <div id="tts-logContainer">
                    <div class="log-entry log-info">ğŸš€ å‡†å¤‡è¿æ¥åˆ° TTS WebSocket æœåŠ¡å™¨...</div>
                </div>
            </div>
        </section>
    </div>

    <script>
    // ===============================================================================
    // ========================== STT SCRIPT =========================================
    // ===============================================================================
    const STT_APP = {
        CONFIG: {
            SAMPLE_RATE: 16000, CHANNELS: 1, CHUNK_SIZE: 2048, VAD_THRESHOLD: 0.15,
            MIN_SPEECH_FRAMES: 2, MAX_SILENCE_FRAMES: 5, AUDIO_RMS_THRESHOLD: 0.05,
            REAL_TIME_FRAMES: 15, TAIL_THRESHOLD_RATIO: 0.4, SPEECH_PADDING_FRAMES: 2,
            END_SPEECH_DELAY_MS: 300,
        },
        elements: {},
        socket: null, audioContext: null, mediaStream: null, audioProcessor: null,
        isRecording: false, isConnected: false, isSpeaking: false,
        speechFrames: [], silenceFrames: 0,

        init() {
            this.cacheElements();
            this.initEventListeners();
            this.updateStatus(false);
            this.addMessage("æ¬¢è¿ä½¿ç”¨VOXELINKå®æ—¶è¯­éŸ³è¯†åˆ«ç³»ç»Ÿ", "system");
            this.addMessage("è¯·ç‚¹å‡»â€œè¿æ¥STTæœåŠ¡â€æŒ‰é’®å¼€å§‹", "system");
            this.checkBrowserCompatibility();
        },

        cacheElements() {
            const ids = [
                'connect-btn', 'disconnect-btn', 'start-btn', 'stop-btn', 'clear-btn',
                'transcript', 'connection-status', 'server-url', 'api-key', 'user-token',
                'llm-api-url', 'check-voiceprint', 'only-register-user', 'identify-unregistered',
                'voice-indicator', 'voice-status', 'recording-status', 'vad-meter-fill',
                'vad-meter-threshold', 'vad-rms', 'vad-threshold', 'vad-confidence',
                'vad-status', 'audio-duration'
            ];
            ids.forEach(id => {
                const camelCaseId = id.replace(/-(\w)/g, (_, c) => c.toUpperCase());
                this.elements[camelCaseId] = document.getElementById(`stt-${id}`);
            });
        },

        initEventListeners() {
            this.elements.connectBtn.addEventListener('click', () => this.connectToServer());
            this.elements.disconnectBtn.addEventListener('click', () => this.disconnectFromServer());
            this.elements.startBtn.addEventListener('click', () => this.startRecording());
            this.elements.stopBtn.addEventListener('click', () => this.stopRecording());
            this.elements.clearBtn.addEventListener('click', () => this.clearTranscript());
            
            const configInputs = ['checkVoiceprint', 'onlyRegisterUser', 'identifyUnregistered', 'userToken', 'llmApiUrl'];
            configInputs.forEach(id => this.elements[id].addEventListener('change', () => this.updateServerConfig()));
            
            window.addEventListener('beforeunload', () => {
                this.stopRecording();
                this.disconnectFromServer();
            });
        },
        
        updateStatus(connected, message = '') {
            this.isConnected = connected;
            this.elements.connectionStatus.className = `status ${connected ? 'connected' : 'disconnected'}`;
            this.elements.connectionStatus.textContent = connected ? `âœ… å·²è¿æ¥åˆ° ${this.elements.serverUrl.value}` : (message || 'âŒ æœªè¿æ¥');
            this.elements.connectBtn.disabled = connected;
            this.elements.disconnectBtn.disabled = !connected;
            this.elements.startBtn.disabled = !connected;
            this.elements.stopBtn.disabled = true;
        },

        addMessage(text, type = 'user') {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', `${type}-message`);
            const timestamp = new Date().toLocaleTimeString();
            messageDiv.textContent = `[${timestamp}] ${text}`;
            this.elements.transcript.appendChild(messageDiv);
            this.elements.transcript.scrollTop = this.elements.transcript.scrollHeight;
        },
        
        addLLMResponse(llmResponse) {
            const responseDiv = document.createElement('div');
            responseDiv.classList.add('message', 'llm-response');
            const timestamp = new Date().toLocaleTimeString();
            responseDiv.innerHTML = `<div class="llm-response-header">[${timestamp}] AIåŠ©æ‰‹:</div><div>${llmResponse.text || JSON.stringify(llmResponse)}</div>`;
            this.elements.transcript.appendChild(responseDiv);
            this.elements.transcript.scrollTop = this.elements.transcript.scrollHeight;
        },
        
        connectToServer() {
            const serverUrl = this.elements.serverUrl.value;
            if (!serverUrl) return this.addMessage("è¯·è¾“å…¥æœåŠ¡å™¨åœ°å€", "error");
            this.addMessage(`æ­£åœ¨è¿æ¥åˆ° ${serverUrl}...`, "system");
            this.socket = new WebSocket(serverUrl);
            this.socket.onopen = () => {
                this.updateStatus(true);
                setTimeout(() => this.updateServerConfig(), 100);
            };
            this.socket.onmessage = (event) => this.handleServerMessage(JSON.parse(event.data));
            this.socket.onclose = (event) => {
                this.addMessage(`STTè¿æ¥å·²å…³é—­ (ä»£ç : ${event.code})`, "system");
                this.updateStatus(false);
                this.stopRecording();
            };
            this.socket.onerror = (error) => this.updateStatus(false, `âŒ è¿æ¥é”™è¯¯: ${error.message}`);
        },
        
        disconnectFromServer() {
            if (this.socket) this.socket.close();
            this.stopRecording();
        },

        handleServerMessage(response) {
            if (response.error) return this.addMessage(`é”™è¯¯: ${response.error}`, "error");
            if (response.message) this.addMessage(response.message, "system");
            if (response.text) {
                let userInfo = response.user_id ? `[${response.user_name || response.user_id}]` : "[æœªè¯†åˆ«ç”¨æˆ·]";
                this.addMessage(`${userInfo} ${response.text}`);
            }
            if (response.llm_response) this.addLLMResponse(response.llm_response);
            if (response.speech_detection) {
                const d = response.speech_detection;
                this.updateVadDebugPanel({ rms: d.rms.value, threshold: d.rms.threshold, confidence: d.vad.confidence, hasSpeech: d.has_speech, audioDuration: d.audio_stats.duration });
            }
        },

        async startRecording() {
            try {
                this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: this.CONFIG.SAMPLE_RATE, channelCount: this.CONFIG.CHANNELS, echoCancellation: true, noiseSuppression: true } });
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: this.CONFIG.SAMPLE_RATE });
                const source = this.audioContext.createMediaStreamSource(this.mediaStream);
                this.audioProcessor = this.audioContext.createScriptProcessor(this.CONFIG.CHUNK_SIZE, 1, 1);
                source.connect(this.audioProcessor);
                this.audioProcessor.connect(this.audioContext.destination);
                
                this.isRecording = true;
                this.isSpeaking = false;
                this.speechFrames = [];
                this.silenceFrames = 0;
                this.elements.startBtn.disabled = true;
                this.elements.stopBtn.disabled = false;
                this.updateRecordingStatus("å·²å¼€å§‹æŒç»­å½•éŸ³ï¼Œç­‰å¾…è¯­éŸ³è¾“å…¥...");
                this.addMessage("å¼€å§‹å½•éŸ³...", "system");

                this.audioProcessor.onaudioprocess = (e) => this.processAudio(e);
            } catch (error) {
                this.addMessage(`å½•éŸ³å¤±è´¥: ${error.message}`, "error");
            }
        },
        
        processAudio(e) {
            if (!this.isRecording) return;
            const inputData = e.inputBuffer.getChannelData(0);
            const rms = this.calculateRMS(inputData);
            const isSpeech = rms > this.CONFIG.AUDIO_RMS_THRESHOLD;
            this.updateVadDebugPanel({ rms: rms, threshold: this.CONFIG.AUDIO_RMS_THRESHOLD, isSpeech: isSpeech, audioDuration: e.inputBuffer.duration });
            
            const audioData = this.convertFloat32ToInt16(inputData);
            if (isSpeech) {
                if (!this.isSpeaking) {
                    this.isSpeaking = true;
                    this.updateVoiceActivityIndicator(true);
                    this.updateRecordingStatus("æ­£åœ¨å½•åˆ¶è¯­éŸ³...");
                }
                this.speechFrames.push(audioData);
                this.silenceFrames = 0;
                if (this.speechFrames.length >= this.CONFIG.REAL_TIME_FRAMES) {
                    this.sendAudioToServer(this.concatenateAudioChunks(this.speechFrames));
                    this.speechFrames = this.speechFrames.slice(-2);
                }
            } else if (this.isSpeaking) {
                this.silenceFrames++;
                if (this.silenceFrames <= this.CONFIG.SPEECH_PADDING_FRAMES) this.speechFrames.push(audioData);
                if (this.silenceFrames >= this.CONFIG.MAX_SILENCE_FRAMES) {
                    if (this.speechFrames.length > 0) this.sendAudioToServer(this.concatenateAudioChunks(this.speechFrames));
                    this.isSpeaking = false;
                    this.speechFrames = [];
                    this.updateVoiceActivityIndicator(false);
                    this.updateRecordingStatus("ç­‰å¾…è¯­éŸ³è¾“å…¥...");
                }
            }
        },

        stopRecording() {
            if (!this.isRecording) return;
            this.isRecording = false;
            if (this.audioProcessor) this.audioProcessor.disconnect();
            if (this.audioContext) this.audioContext.close();
            if (this.mediaStream) this.mediaStream.getTracks().forEach(track => track.stop());
            this.audioProcessor = this.audioContext = this.mediaStream = null;
            this.elements.startBtn.disabled = !this.isConnected;
            this.elements.stopBtn.disabled = true;
            this.updateVoiceActivityIndicator(false);
            this.updateRecordingStatus("å½•éŸ³å·²åœæ­¢");
            if (this.isConnected) this.addMessage("å½•éŸ³å·²åœæ­¢", "system");
        },

        sendAudioToServer(audioBuffer) {
            if (!this.socket || this.socket.readyState !== WebSocket.OPEN) return;
            const message = {
                action: "audio",
                data: { audio_data: this.arrayBufferToBase64(audioBuffer.buffer), format: "pcm" }
            };
            this.socket.send(JSON.stringify(message));
        },

        updateServerConfig() {
            if (!this.socket || this.socket.readyState !== WebSocket.OPEN) return;
            const configMessage = {
                action: "config",
                data: {
                    check_voiceprint: this.elements.checkVoiceprint.checked,
                    only_register_user: this.elements.onlyRegisterUser.checked,
                    identify_unregistered: this.elements.identifyUnregistered.checked,
                    user_token: this.elements.userToken.value.trim(),
                    llm_api_url: this.elements.llmApiUrl.value.trim()
                }
            };
            this.socket.send(JSON.stringify(configMessage));
        },
        
        updateVadDebugPanel(data) {
            if (data.rms !== undefined) {
                const maxRms = Math.max(0.1, data.threshold * 4);
                this.elements.vadMeterFill.style.width = `${Math.min(100, (data.rms / maxRms) * 100)}%`;
                this.elements.vadMeterFill.style.backgroundColor = data.isSpeech ? '#2ecc71' : '#3498db';
                this.elements.vadMeterThreshold.style.left = `${Math.min(100, (data.threshold / maxRms) * 100)}%`;
                this.elements.vadRms.textContent = data.rms.toFixed(4);
                this.elements.vadThreshold.textContent = data.threshold.toFixed(4);
            }
            if (data.confidence !== undefined) this.elements.vadConfidence.textContent = (data.confidence * 100).toFixed(1) + '%';
            if (data.isSpeech !== undefined) {
                const status = data.isSpeech ? 'æ£€æµ‹åˆ°è¯­éŸ³' : 'é™éŸ³';
                this.elements.vadStatus.textContent = status;
                this.elements.vadStatus.style.color = data.isSpeech ? '#2ecc71' : '#7f8c8d';
            }
            if (data.audioDuration !== undefined) this.elements.audioDuration.textContent = data.audioDuration.toFixed(2) + 's';
        },

        updateVoiceActivityIndicator(isActive) {
            this.elements.voiceIndicator.classList.toggle('active', isActive);
            this.elements.voiceStatus.textContent = isActive ? 'æ£€æµ‹åˆ°è¯­éŸ³ (æ­£åœ¨è¯†åˆ«)' : 'ç­‰å¾…è¯­éŸ³è¾“å…¥';
        },
        updateRecordingStatus(status) { this.elements.recordingStatus.textContent = status; },
        clearTranscript() { this.elements.transcript.innerHTML = ''; this.addMessage("è®°å½•å·²æ¸…ç©º", "system"); },
        calculateRMS: (buffer) => Math.sqrt(buffer.reduce((sum, val) => sum + val * val, 0) / buffer.length),
        convertFloat32ToInt16: (buffer) => new Int16Array(buffer.map(n => Math.max(-32768, Math.min(32767, n * 32768)))),
        concatenateAudioChunks(chunks) {
            const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
            const result = new Int16Array(totalLength);
            let offset = 0;
            for (const chunk of chunks) { result.set(chunk, offset); offset += chunk.length; }
            return result;
        },
        arrayBufferToBase64: (buffer) => btoa(String.fromCharCode.apply(null, new Uint8Array(buffer))),
        checkBrowserCompatibility() {
            if (!window.WebSocket) this.addMessage("é”™è¯¯: æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWebSocket", "error");
            if (!window.AudioContext && !window.webkitAudioContext) this.addMessage("é”™è¯¯: æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒAudioContext", "error");
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) this.addMessage("é”™è¯¯: æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ•è·", "error");
        },
    };


    // ===============================================================================
    // ========================== TTS SCRIPT =========================================
    // ===============================================================================
    const TTS_APP = {
        ws: null, audioQueue: [], currentAudioIndex: -1, currentAudio: null,
        isPlaying: false, isPaused: false, connectTime: null, connectionTimer: null,
        totalReceived: 0, elements: {},
        
        init() {
            this.cacheElements();
            this.initEventListeners();
            this.updateStats();
            this.updatePlaybackControls();
        },

        cacheElements() {
            const ids = [
                'serverUrl', 'token', 'connectBtn', 'disconnectBtn', 'connectionStatus', 
                'totalReceived', 'totalPlayed', 'queueLength', 'connectionTime', 'playNextBtn',
                'pauseBtn', 'stopBtn', 'clearQueueBtn', 'markAllUnplayedBtn', 'autoPlay', 
                'audioQueue', 'logContainer'
            ];
            ids.forEach(id => {
                const camelCaseId = id.replace(/-(\w)/g, (_, c) => c.toUpperCase());
                this.elements[camelCaseId] = document.getElementById(`tts-${id}`);
            });
        },

        initEventListeners() {
            this.elements.connectBtn.addEventListener('click', () => this.connectWebSocket());
            this.elements.disconnectBtn.addEventListener('click', () => this.disconnectWebSocket());
            this.elements.playNextBtn.addEventListener('click', () => this.playNextUnplayed());
            this.elements.pauseBtn.addEventListener('click', () => this.pauseAudio());
            this.elements.stopBtn.addEventListener('click', () => this.stopAudio());
            this.elements.clearQueueBtn.addEventListener('click', () => this.clearQueue());
            this.elements.markAllUnplayedBtn.addEventListener('click', () => this.markAllAsUnplayed());
        },

        updateStats() {
            const playedCount = this.audioQueue.filter(item => item.played).length;
            this.elements.totalReceived.textContent = this.totalReceived;
            this.elements.totalPlayed.textContent = playedCount;
            this.elements.queueLength.textContent = this.audioQueue.length - playedCount;
            if (this.connectTime) {
                const duration = Math.floor((Date.now() - this.connectTime) / 1000);
                const minutes = Math.floor(duration / 60);
                const seconds = duration % 60;
                this.elements.connectionTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            } else {
                this.elements.connectionTime.textContent = '--';
            }
        },

        addLog(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            this.elements.logContainer.appendChild(logEntry);
            this.elements.logContainer.scrollTop = this.elements.logContainer.scrollHeight;
            if (this.elements.logContainer.children.length > 50) this.elements.logContainer.removeChild(this.elements.logContainer.firstChild);
        },

        connectWebSocket() {
            const serverUrl = this.elements.serverUrl.value.trim();
            const token = this.elements.token.value.trim();
            if (!serverUrl || !token) return this.addLog('âŒ è¯·è¾“å…¥æœåŠ¡å™¨åœ°å€å’Œ Token', 'error');
            
            const wsUrl = `${serverUrl}/ws/${encodeURIComponent(token)}`;
            this.addLog(`ğŸ”„ æ­£åœ¨è¿æ¥åˆ°: ${wsUrl}`, 'info');
            this.updateConnectionStatus('connecting', 'ğŸ”„ è¿æ¥ä¸­...');
            
            this.ws = new WebSocket(wsUrl);
            this.ws.onopen = () => {
                this.addLog('âœ… TTS WebSocket è¿æ¥æˆåŠŸï¼', 'success');
                this.updateConnectionStatus('connected', 'âœ… å·²è¿æ¥');
                this.elements.connectBtn.disabled = true;
                this.elements.disconnectBtn.disabled = false;
                this.connectTime = Date.now();
                if (this.connectionTimer) clearInterval(this.connectionTimer);
                this.connectionTimer = setInterval(() => this.updateStats(), 1000);
                // Heartbeat
                setInterval(() => { if (this.ws && this.ws.readyState === WebSocket.OPEN) this.ws.send('ping'); }, 30000);
            };
            this.ws.onmessage = (event) => {
                if (event.data === 'pong') return;
                try { this.handleAudioMessage(JSON.parse(event.data)); } catch (e) { this.addLog(`âŒ æ¶ˆæ¯è§£æå¤±è´¥: ${e.message}`, 'error'); }
            };
            this.ws.onclose = (event) => { this.addLog(`ğŸ”Œ TTS WebSocket è¿æ¥å…³é—­ (ä»£ç : ${event.code})`, 'info'); this.resetConnectionState(); };
            this.ws.onerror = (error) => { this.addLog(`âŒ TTS WebSocket é”™è¯¯`, 'error'); this.resetConnectionState(); };
        },

        disconnectWebSocket() {
            if (this.ws) { this.ws.close(); this.ws = null; }
            this.resetConnectionState();
        },

        resetConnectionState() {
            this.updateConnectionStatus('disconnected', 'âŒ è¿æ¥å·²æ–­å¼€');
            this.elements.connectBtn.disabled = false;
            this.elements.disconnectBtn.disabled = true;
            this.connectTime = null;
            if (this.connectionTimer) { clearInterval(this.connectionTimer); this.connectionTimer = null; }
            this.updateStats();
        },
        
        updateConnectionStatus(status, message) {
            this.elements.connectionStatus.className = `status ${status}`;
            this.elements.connectionStatus.textContent = message;
        },

        handleAudioMessage(data) {
            if (data.type !== 'audio') return;
            this.addLog(`ğŸµ æ”¶åˆ°éŸ³é¢‘: ${data.text}`, 'success');
            const audioItem = {
                id: Date.now() + Math.random(), text: data.text, character: data.character,
                mood: data.mood, sampleRate: data.sample_rate, audioBase64: data.audio_base64,
                timestamp: data.timestamp, played: false,
            };
            this.audioQueue.push(audioItem);
            this.audioQueue.sort((a, b) => a.timestamp - b.timestamp);
            this.totalReceived++;
            this.updateStats();
            this.updateAudioQueueDisplay();
            if (this.elements.autoPlay.checked && !this.isPlaying) this.playNextUnplayed();
        },

        updateAudioQueueDisplay() {
            if (this.audioQueue.length === 0) {
                this.elements.audioQueue.innerHTML = '<div style="text-align: center; color: #718096; padding: 20px;">æš‚æ— éŸ³é¢‘æ–‡ä»¶...</div>';
                return;
            }
            this.elements.audioQueue.innerHTML = '';
            this.audioQueue.forEach((item, index) => {
                const itemDiv = document.createElement('div');
                let statusClass = item.played ? 'played' : (index === this.currentAudioIndex ? 'playing' : '');
                let statusIcon = item.played ? 'âœ… ' : (index === this.currentAudioIndex ? 'ğŸµ ' : '');
                itemDiv.className = `audio-item ${statusClass}`;
                itemDiv.innerHTML = `
                    <div class="audio-info">
                        <div class="audio-text">${statusIcon}${item.text}</div>
                        <div class="audio-meta">${item.character}/${item.mood} | ${new Date(item.timestamp).toLocaleTimeString()}</div>
                    </div>
                    <div class="audio-controls">
                        <div class="progress-bar" style="display: ${index === this.currentAudioIndex ? 'block' : 'none'}"><div class="progress-fill" id="tts-progress-${index}"></div></div>
                        <button onclick="TTS_APP.playSpecific(${index})" ${item.played || (index === this.currentAudioIndex && this.isPlaying) ? 'disabled' : ''}>â–¶ï¸</button>
                        <button onclick="TTS_APP.replayAudio(${index})" ${!item.played ? 'style="display:none"' : ''}>ğŸ”„</button>
                        <button onclick="TTS_APP.removeFromQueue(${index})">ğŸ—‘ï¸</button>
                    </div>`;
                this.elements.audioQueue.appendChild(itemDiv);
            });
            this.updatePlaybackControls();
        },

        playSpecific(index) {
            if (index >= 0 && index < this.audioQueue.length && !this.audioQueue[index].played) {
                this.stopAudio();
                this.currentAudioIndex = index;
                this.playCurrentAudio();
            }
        },
        
        replayAudio(index) {
            if (index >= 0 && index < this.audioQueue.length) {
                this.audioQueue[index].played = false;
                this.playSpecific(index);
            }
        },

        playNextUnplayed() {
            const nextIndex = this.audioQueue.findIndex(item => !item.played);
            if (nextIndex === -1) {
                this.addLog('âœ… æ‰€æœ‰éŸ³é¢‘éƒ½å·²æ’­æ”¾å®Œæˆ', 'success');
                return;
            }
            this.currentAudioIndex = nextIndex;
            this.playCurrentAudio();
        },

        playCurrentAudio() {
            if (this.currentAudioIndex < 0 || this.currentAudioIndex >= this.audioQueue.length) return;
            const audioItem = this.audioQueue[this.currentAudioIndex];
            if (audioItem.played) {
                if (this.elements.autoPlay.checked) setTimeout(() => this.playNextUnplayed(), 100);
                return;
            }
            const audioBlob = this.base64ToBlob(audioItem.audioBase64, 'audio/wav');
            this.currentAudio = new Audio(URL.createObjectURL(audioBlob));
            this.currentAudio.onplay = () => { this.isPlaying = true; this.isPaused = false; this.updateAudioQueueDisplay(); };
            this.currentAudio.onpause = () => { this.isPaused = true; this.isPlaying = false; this.updatePlaybackControls(); };
            this.currentAudio.ontimeupdate = () => {
                const progressFill = document.getElementById(`tts-progress-${this.currentAudioIndex}`);
                if (progressFill) progressFill.style.width = `${(this.currentAudio.currentTime / this.currentAudio.duration) * 100}%`;
            };
            this.currentAudio.onended = () => {
                audioItem.played = true; this.isPlaying = false; this.isPaused = false;
                this.updateStats();
                if (this.elements.autoPlay.checked) {
                    setTimeout(() => this.playNextUnplayed(), 500);
                } else {
                    this.currentAudioIndex = -1;
                    this.updateAudioQueueDisplay();
                }
            };
            this.currentAudio.onerror = (e) => { this.addLog('âŒ æ’­æ”¾é”™è¯¯', 'error'); this.isPlaying = false; };
            this.currentAudio.play();
        },
        
        pauseAudio() { if (this.currentAudio && this.isPlaying) this.currentAudio.pause(); },
        stopAudio() {
            if (this.currentAudio) { this.currentAudio.pause(); this.currentAudio.currentTime = 0; }
            this.isPlaying = false; this.isPaused = false; this.currentAudioIndex = -1;
            this.updateAudioQueueDisplay();
        },
        
        removeFromQueue(index) {
            if (index === this.currentAudioIndex) this.stopAudio();
            this.audioQueue.splice(index, 1);
            if (this.currentAudioIndex > index) this.currentAudioIndex--;
            this.updateAudioQueueDisplay(); this.updateStats();
        },

        clearQueue() { this.stopAudio(); this.audioQueue = []; this.totalReceived = 0; this.updateAudioQueueDisplay(); this.updateStats(); },
        markAllAsUnplayed() { this.audioQueue.forEach(item => item.played = false); this.updateAudioQueueDisplay(); this.updateStats(); },

        updatePlaybackControls() {
            const hasUnplayed = this.audioQueue.some(item => !item.played);
            this.elements.playNextBtn.disabled = !hasUnplayed || this.isPlaying;
            this.elements.pauseBtn.disabled = !this.isPlaying;
            this.elements.stopBtn.disabled = !this.isPlaying && !this.isPaused;
        },
        base64ToBlob(base64, mimeType) {
            const byteChars = atob(base64);
            const byteNumbers = new Array(byteChars.length);
            for (let i = 0; i < byteChars.length; i++) byteNumbers[i] = byteChars.charCodeAt(i);
            return new Blob([new Uint8Array(byteNumbers)], {type: mimeType});
        }
    };

    document.addEventListener('DOMContentLoaded', () => {
        STT_APP.init();
        TTS_APP.init();
    });
    </script>
</body>
</html> 