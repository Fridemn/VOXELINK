<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOXELINK Pipeline 测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .status.connected {
            background-color: #d4edda;
            color: #155724;
        }
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }
        .status.processing {
            background-color: #fff3cd;
            color: #856404;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .audio-controls {
            margin: 20px 0;
        }
        .response {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            white-space: pre-wrap;
        }
        .transcription {
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>VOXELINK Pipeline WebSocket 测试</h1>

    <div class="container">
        <h2>连接状态</h2>
        <div id="status" class="status disconnected">未连接</div>
        <button id="connectBtn">连接WebSocket</button>
        <button id="disconnectBtn" disabled>断开连接</button>
    </div>

    <div class="container">
        <h2>配置</h2>
        <label>LLM模型:</label>
        <select id="modelSelect">
            <option value="deepseek/deepseek-v3-0324">DeepSeek v3</option>
            <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
        </select>
        <br><br>
        <label><input type="checkbox" id="streamCheck" checked> 流式输出</label>
        <label><input type="checkbox" id="ttsCheck" checked> 启用TTS</label>
        <br><br>
        <button id="updateConfigBtn">更新配置</button>
    </div>

    <div class="container">
        <h2>音频输入</h2>
        <div class="audio-controls">
            <button id="recordBtn">开始录音</button>
            <button id="stopBtn" disabled>停止录音</button>
            <button id="playBtn" disabled>播放录音</button>
        </div>
        <div id="recordingStatus"></div>
        <button id="sendAudioBtn" disabled>发送音频到Pipeline</button>
    </div>

    <div class="container">
        <h2>处理结果</h2>
        <div id="transcription" class="transcription" style="display: none;">
            <strong>语音识别结果:</strong> <span id="transcriptionText"></span>
        </div>
        <div id="response" class="response" style="display: none;">
            <strong>LLM回复:</strong><br>
            <span id="responseText"></span>
        </div>
        <div id="audioOutput" style="display: none;">
            <strong>合成音频:</strong><br>
            <audio id="outputAudio" controls></audio>
        </div>
    </div>

    <script>
        // WebM转WAV转换函数
        async function convertWebMToWAV(webmBlob) {
            return new Promise(async (resolve, reject) => {
                try {
                    // 创建AudioContext
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // 解码WebM音频
                    const arrayBuffer = await webmBlob.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    // 创建WAV文件
                    const wavBlob = audioBufferToWav(audioBuffer);
                    resolve(wavBlob);
                    
                    audioContext.close();
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // AudioBuffer转WAV的辅助函数
        function audioBufferToWav(buffer) {
            const length = buffer.length;
            const sampleRate = buffer.sampleRate;
            const numChannels = buffer.numberOfChannels;
            
            // 创建WAV文件缓冲区
            const arrayBuffer = new ArrayBuffer(44 + length * numChannels * 2);
            const view = new DataView(arrayBuffer);
            
            // WAV文件头
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * numChannels * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true);
            view.setUint16(32, numChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * numChannels * 2, true);
            
            // 写入音频数据
            let offset = 44;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample * 0x7FFF, true);
                    offset += 2;
                }
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        let ws = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let recordedAudio = null;
        let audioQueue = [];
        let isPlaying = false;

        // 播放下一个音频的函数
        function playNextAudio() {
            if (audioQueue.length > 0 && !isPlaying) {
                const uint8Array = audioQueue.shift();
                const audioBlob = new Blob([uint8Array], { type: 'audio/wav' });
                const audioUrl = URL.createObjectURL(audioBlob);
                outputAudio.src = audioUrl;
                outputAudio.play();
                isPlaying = true;
                outputAudio.onended = () => {
                    isPlaying = false;
                    playNextAudio();
                };
            }
        }

        // DOM元素
        const statusDiv = document.getElementById('status');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopBtn');
        const playBtn = document.getElementById('playBtn');
        const sendAudioBtn = document.getElementById('sendAudioBtn');
        const transcriptionDiv = document.getElementById('transcription');
        const transcriptionText = document.getElementById('transcriptionText');
        const responseDiv = document.getElementById('response');
        const responseText = document.getElementById('responseText');
        const audioOutputDiv = document.getElementById('audioOutput');
        const outputAudio = document.getElementById('outputAudio');

        // 连接WebSocket
        connectBtn.addEventListener('click', () => {
            if (ws) {
                ws.close();
            }

            ws = new WebSocket('ws://localhost:8080/stt/ws/pipeline');

            ws.onopen = () => {
                statusDiv.textContent = '已连接';
                statusDiv.className = 'status connected';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                console.log('WebSocket连接已建立');
            };

            ws.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    const data = JSON.parse(event.data);
                    handleMessage(data);
                } else {
                    // Binary audio data
                    event.data.arrayBuffer().then(buffer => {
                        const uint8Array = new Uint8Array(buffer);
                        audioQueue.push(uint8Array);
                        playNextAudio();
                    });
                }
            };

            ws.onclose = () => {
                statusDiv.textContent = '未连接';
                statusDiv.className = 'status disconnected';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                console.log('WebSocket连接已关闭');
            };

            ws.onerror = (error) => {
                console.error('WebSocket错误:', error);
                statusDiv.textContent = '连接错误';
                statusDiv.className = 'status disconnected';
            };
        });

        // 断开连接
        disconnectBtn.addEventListener('click', () => {
            if (ws) {
                ws.close();
            }
        });

        // 更新配置
        document.getElementById('updateConfigBtn').addEventListener('click', () => {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('请先连接WebSocket');
                return;
            }

            const config = {
                model: document.getElementById('modelSelect').value,
                stream: document.getElementById('streamCheck').checked,
                tts: document.getElementById('ttsCheck').checked
            };

            ws.send(JSON.stringify({
                action: 'config',
                data: config
            }));
        });

        // 开始录音
        recordBtn.addEventListener('click', async () => {
            try {
                // 请求音频流，指定采样率
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                
                // 创建MediaRecorder，指定MIME类型
                const options = { mimeType: 'audio/webm;codecs=opus' };
                mediaRecorder = new MediaRecorder(stream, options);

                audioChunks = [];
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    // 将WebM转换为WAV格式
                    recordedAudio = await convertWebMToWAV(new Blob(audioChunks, { type: 'audio/webm' }));
                    playBtn.disabled = false;
                    sendAudioBtn.disabled = false;
                    document.getElementById('recordingStatus').textContent = '录音完成';
                };

                mediaRecorder.start();
                recordBtn.disabled = true;
                stopBtn.disabled = false;
                document.getElementById('recordingStatus').textContent = '正在录音...';

            } catch (error) {
                console.error('录音失败:', error);
                alert('无法访问麦克风: ' + error.message);
            }
        });

        // 停止录音
        stopBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                recordBtn.disabled = false;
                stopBtn.disabled = true;
            }
        });

        // 播放录音
        playBtn.addEventListener('click', () => {
            if (recordedAudio) {
                const audioUrl = URL.createObjectURL(recordedAudio);
                const audio = new Audio(audioUrl);
                audio.play();
            }
        });

        // 发送音频
        sendAudioBtn.addEventListener('click', async () => {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('请先连接WebSocket');
                return;
            }

            if (!recordedAudio) {
                alert('请先录音');
                return;
            }

            statusDiv.textContent = '处理中...';
            statusDiv.className = 'status processing';

            // 清空之前的显示
            transcriptionDiv.style.display = 'none';
            responseDiv.style.display = 'none';
            audioOutputDiv.style.display = 'none';
            transcriptionText.textContent = '';
            responseText.textContent = '';
            audioQueue = []; // 清空音频队列
            isPlaying = false; // 重置播放状态

            try {
                // 转换为ArrayBuffer
                const arrayBuffer = await recordedAudio.arrayBuffer();
                
                // 使用标准的base64编码方式
                const uint8Array = new Uint8Array(arrayBuffer);
                const binaryString = Array.from(uint8Array, byte => String.fromCharCode(byte)).join('');
                const base64Audio = btoa(binaryString);

                ws.send(JSON.stringify({
                    action: 'audio',
                    data: {
                        audio_data: base64Audio,
                        format: 'wav'
                    }
                }));

            } catch (error) {
                console.error('发送音频失败:', error);
                alert('发送音频失败');
                statusDiv.textContent = '发送失败';
                statusDiv.className = 'status disconnected';
            }
        });

        // 处理接收到的消息
        function handleMessage(data) {
            console.log('收到消息:', data);

            if (data.success) {
                if (data.message) {
                    // 连接或配置消息
                    console.log(data.message);
                    return;
                }

                if (data.type === 'stream_chunk') {
                    // 流式数据块
                    const chunkData = data.data;

                    if (chunkData.transcription) {
                        transcriptionDiv.style.display = 'block';
                        transcriptionText.textContent = chunkData.transcription;
                    }

                    if (chunkData.text) {
                        responseDiv.style.display = 'block';
                        responseText.textContent += chunkData.text;
                    }

                    if (chunkData.audio) {
                        // 收到音频数据，推入队列
                        audioOutputDiv.style.display = 'block';
                        const audioData = atob(chunkData.audio);
                        const uint8Array = new Uint8Array(audioData.length);
                        for (let i = 0; i < audioData.length; i++) {
                            uint8Array[i] = audioData.charCodeAt(i);
                        }
                        audioQueue.push(uint8Array);
                        playNextAudio();

                        statusDiv.textContent = '处理完成';
                        statusDiv.className = 'status connected';
                    }
                } else if (data.type === 'response') {
                    // 非流式响应
                    const responseData = data.data;

                    if (responseData.response_text) {
                        responseDiv.style.display = 'block';
                        responseText.textContent = responseData.response_text;
                    }

                    if (responseData.audio) {
                        audioOutputDiv.style.display = 'block';
                        const audioData = atob(responseData.audio);
                        const uint8Array = new Uint8Array(audioData.length);
                        for (let i = 0; i < audioData.length; i++) {
                            uint8Array[i] = audioData.charCodeAt(i);
                        }
                        audioQueue.push(uint8Array);
                        playNextAudio();
                    }

                    statusDiv.textContent = '处理完成';
                    statusDiv.className = 'status connected';
                }
            } else {
                // 错误消息
                console.error('处理失败:', data.error);
                statusDiv.textContent = '处理失败: ' + data.error;
                statusDiv.className = 'status disconnected';
            }
        }
    </script>
</body>
</html>